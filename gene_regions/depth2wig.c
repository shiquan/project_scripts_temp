#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include "utils.h"

#include <htslib/hts.h>
#include <htslib/kstring.h>
#include <htslib/kseq.h>
#include <zlib.h>

struct args {
    const char *input_fname;
    const char *output_fname;
    const char *name;
    const char *color;
    const char *visibility;
    htsFile *fp;
    FILE *fp_out;
};
struct args args = {
    .input_fname = 0,
    .output_fname = 0,
    .name = 0,
    .color = 0,
    .visibility = 0,
    .fp = 0,
    .fp_out = 0,
};

int parse_args(int argc, char **argv)
{
    if (argc == 1)
	error("Usage: depth2wig depth.tsv.gz -o out.wig");

    int i;
    for (i = 1; i < argc; ) {
	const char *a = argv[i++];
	const char **var = 0;
	if (strcmp(a, "-o") == 0 && args.output_fname == 0)
	    var = &args.output_fname;
	else if (strcmp(a, "-name") == 0 && args.name == 0)
	    var = &args.name;
	else if ( strcmp(a, "-vis") == 0 && args.visibility == 0)
	    var = &args.visibility;
	else if ( strcmp(a, "-color") == 0 && args.color == 0)
	    var = &args.color;
	
	if (var != 0) {
	    if (i == argc)
		error("Missing an argument after %s", a);
	    *var = argv[i++];
	    continue;
	}
	if (args.input_fname == 0) {
	    args.input_fname = a;
	    continue;
	}
	error("Unknown argument : %s", a);
    }
    args.fp = hts_open(args.input_fname, "r");
    if (args.fp == 0)
	error("%s : %s.", args.input_fname, strerror(errno));
    args.fp_out = args.output_fname == 0 ? stdout : fopen(args.output_fname, "w");
    if (args.fp_out == 0)
	error("%s : %s.", args.output_fname, strerror(errno));
    fprintf(args.fp_out, "track type=wiggle_0");
    if ( args.name )
	fprintf(args.fp_out, " name=\"%s\"", args.name);
    if ( args.color )
	fprintf(args.fp_out, " color=\"%s\"", args.color);
    if ( args.visibility )
	fprintf(args.fp_out, " visibility=\"%s\"", args.visibility);
    else
	fprintf(args.fp_out, " visibility=\"full\"");

    fputs("\n", args.fp_out);
    return 0;
}
void args_destroy()
{
    hts_close(args.fp);
    fclose(args.fp_out);
}
int export_wig()
{
    kstring_t string = { 0, 0, 0};
    char *last_chrom = 0;
    
    while (1) {
	string.l = 0;
	if ( hts_getline(args.fp, KS_SEP_LINE, &string) < 0)
	    break;
	if ( string.s[0] == '#')
	    continue;
	int nfields;
	int *splits = ksplit(&string, '\t', &nfields);
	// only accept depth file, generated by bamdst
	assert(nfields > 3);
	char *chrom = string.s+splits[0];
	int start = atoi(string.s+splits[1]);
	int depth = atoi(string.s + splits[2]);
	if (last_chrom == 0 || strcmp(chrom, last_chrom)) {
	    if (last_chrom )
		free(last_chrom);
	    last_chrom = strdup(chrom);
	    fprintf(args.fp_out, "variableStep  chrom=%s\n", last_chrom);
	}
	fprintf(args.fp_out, "%d\t%d\n", start, depth);	
    }
    return 0;
}
int main(int argc, char **argv)
{
    parse_args(argc, argv);

    export_wig();
    args_destroy();
    return 0;
}
